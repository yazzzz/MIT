MIT 6.00sc

lec 1:
declarative: comprised of statements of fact. doesn't tell you how to do it. tells you how to test.
imperative: how to accomplish something, like a recipe

good enough = approximation algorithms

example: alg to get the square root of a number:

sq root of 25:
guess 3
3 ** 2 = 9. not close enough
(3 + 25/3)/2 = 5.6666666
5.6666 ** 2 == 32.04 not close enough

how to perform a computation is an ALGORITHM
ALGORYTHM has converged (halted)

instructions
order of execution
flow of control
termination condition (tells us when to stop)

original computers were fixed program computers. designed for specific things.
alan turing machine for code breaking. the machines were limited. invention of stored
program computer changed things. instructions are the same as data, so treat data
and programs as the same thing. no diff btwn 25 (the input) and the steps 
of the algorythm. became flexible, programs can produce data and programs. 
people began to think about computers then as interpreter:

interpreter: prog that can execute any legal set of instructions

stored program computer:
memory
control unit (fetch something from/to memory, put stuff on the screen)
arightmetic logic unit - brains
accumulator - stores the results
input/output

stored program computer is more versatile than a fixed-program computer, since 
it interprets a program given to it and carries out those instructions, as opposed to being built to do one thing.

alan turing:
6 instructions operating on 1 bit of information. all you needed.


a programing lang provides a primitive set of primitive instructions 
(primitive control structures) and that's all. one lang from another is
defined by what these instructions, flow control, combining mechanisms


the computer will do exactly what you tell it to do.

define a language:
syntax: which sequences of characters and symbols constitute a well-formed string (not
necessarily meaningful) 
static: semantics: which well-formed strings have a meaning. ex: 3/'abc'
semantics: what that meaning is

Syntax determines whether a string is legal, static semantics determine whether the string has meaning, and semantics assigns a meaning to a legal sentence (assuming no static semantic errors).


a program might:
crash: stop running
might never stop (inf loop)
run to completion, but give wrong answer - BAD THING HAPPEN

rigorous static semantics is good. python is mediochre.
python is interpreted language.

interpreted:
src - checker - interpreter - output
compiled:
src - checker/compiler - translate to object code - interpreter - output

compiled gives you error in terms of object code, which is harder. compiled languages
are more efficient (faster)

lec 2:

IDLE: integrated dev environment, includes text editor, shell, syntax hilighting, debugger

everything in python is an object. each object has a type (kind of object and what 
we can do with it). 

2 fundamental types:
scalar - indivisible

literal = how we type it. 3 is 3.

floats are not real numbers. floats are approx to reals, not the same. usually you can
pretend.

boolean = True and False

None = Nonetype

strings = strings of characters

expression is s seq of operands and operators. operands are objects.

the operator + is overloaded, have meaning that depends on the type of operands.


'a' + 3  is a static semantic error but is syntactically correct (operand operator operand)

'a' + '3'  is ok
'a' + str(3) is ok, type conversion
int('3')
int('.0') givs an error


program is a sequence of commands

diff language have a diff notion of what a variable means. in python, variable is just
a name for an object. assignment statement in python binds a name to and object. bind
name x to object 3. bind x to the expression x*x, then binds x to that result.

comments are there to explain your thinking, not how python works

use raw_input only. it expects a string.

*straight line programs: sequence of commands one after the other, no loops, ever command
executed once.

tests make things interesting (decisions)
conditionals - if/elif/else


*branching programs with conditionals. 

time to run should depend on size of data, not number of commands (ie length of program)

*looping construct (iteration), turing complete. flow of control. you can go back and exec
statements you've already executed.

-------- lec 2, recitation

sequence of instructions loaded into memory and executed by the the cpu
cpu looks at memory and says this is an instruction i can execute

cpu understands 1s and 0s
programs are abstractions so we can understand what we're telling the computer
to do with 1s and 0s.

var + var  is good syntax python
var var + is not good syntax for python

static semantics: syntactically valid statements that mean something 
a = 5
a/2 valid syntactically and means 5/2 which is 2

c = 2
d = 'foo'
c/d valid syntactically but has no meaning in python

semantics: syntax is correct and means something, but doesn't work properly.
could also be that we get the wrong answer, but the code is valid and runs w/out
error.

a = 6
a/0 = division by zero error

sequences of expressions comprised of operators, operand

myvar = 'a string'
myvar (variable is an operand) = (operator: does something to things) 'a string' (string is an operand)

operators, operands, variables, etc are all objects in python

objects have types: int, float, strings, booleans, noneType, lists, tuples, dicts

string operator: 
+ is concatenation: sticking 2 things together


comparison operators < > <= >= != == not and or  
all of these return True or False


flow control: conditonals (if/elif/else) and loops (while/for)

---------------

review:

Types are classifications of objects, which is what Python, as an OOP language, deals with. They determine how those objects are dealt with (for example, adding two integers results in an integer, two strings results in a concatenated string, and an integer and a string results in an error).


An expression is composed of objects (or operands) and operators, and can be interpreted into a value.

A type conversion turns one type of object into another. For example, applying str to the integer 3 results in the string '3'.

Keywords are words that have special meanings within a language. Many editors will display them in special colors. These words cannot be used as variables.

A straight line program simply goes through and carries out each step. A branching program will do different things depending on conditions set within the program.

A conditional statement starts with an if statement, and can also include elif and else statements.


